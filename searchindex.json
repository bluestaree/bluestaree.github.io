{"categories":[{"title":"SpringBoot","uri":"https://bluestaree.github.io/categories/springboot/"},{"title":"数据结构与算法","uri":"https://bluestaree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"title":"笔记","uri":"https://bluestaree.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"title":"面试题","uri":"https://bluestaree.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"posts":[{"content":"  转载 · 原文链接：https://blog.csdn.net/wu1317581750/java/article/details/81662929\n hibernate运行原理： hibernate里面提供了3个核心接口 Configuration、SessionFactory、Session\nhibernate启动的时候利用Configuration读取xml配置文件\n通过配置文件创建SessionFactory对象，初始化hibernate基本信息\n获取session然后调用CRUD方法进行数据操作，hibernate会把我们的数据进行三种状态的划分，然后根据状态进行管理我们的数据，对应的发送SQL进行数据操作\n关闭session，如果有事务的情况下，需要手动获取事务并开启，然后事务结束后提交事务。\n在提交事务的时候，去验证我们的快照里面的数据和缓存数据是否一致，如果不一致，发送SQL进行修改，\nhibernate的get方法和load方法的区别 get和load都是利用主键策略查询数据，\nget默认不使用懒加载机制，load默认要使用懒加载机制，所谓的懒加载就是我们这个数据如果不使用，hibernate就不发送SQL到数据库查询数据。\n当查询数据库不存在的数据的时候，get方法返回null，load方法抛出空指针异常，\n原因是因为，load方法采用的动态代理的方式实现的，我们使用load方法的时候，hibernate会创建一个该实体的代理对象，该代理只保存了该对象的ID，当我们访问该实体对象其他属性，hibernate就发送SQL查询数据封装到代理对象，然后在利用代理对象返回给我们实际的数据，\nhibernate的数据三种状态 hibernate把他所管理的数据划分为三种状态\n瞬时的（刚new出来的数据–内存有，数据库没有）\n持久的 （从数据查询的，或者刚保存到数据库，session没关闭的， 数据库有，内存也有）\n游离的 、脱管的（数据库有，内存没有）\n实际上hibernate对数据划分三种状态，主要是为了管理我们持久的数据，在事务提交的时候，hibernate去对比处于持久状态的数据是否发生改变，(快照区、一级缓存区)，当我们会话结束前，对持久状态数据进行了修改的话，快照区的数据会跟着改变。当session提交事务的时候，如果发现快照区和一级缓存的数据不一致，就会发送SQL进行修改。\n简述hibernate的缓存机制 hibernate分为2级缓存\n一级缓存又叫session缓存，又叫事务级缓存，生命周期从事务开始到事务结束，一级缓存是hibernate自带的，暴力使用，当我们一创建session就已有这个缓存了。数据库就会自动往缓存存放，\n二级缓存是hibernate提供的一组开放的接口方式实现的，都是通过整合第三方的缓存框架来实现的，二级缓存又叫sessionFactory的缓存，可以跨session访问。常用的EHcache、OScache，这个需要一些配置。\n当我们每次 查询数据的时候，首先是到一级缓存查看是否存在该对象，如果有直接返回，如果没有就去二级缓存进行查看，如果有直接返回，如果没有在发送SQL到数据库查询数据，\n当SQL发送查询回该数据的时候，hibernate会把该对象以主键为标记的形式存储到二级缓存和一级缓存，如果返回的是集合，会把集合打散然后以主键的形式存储到缓存。一级缓存和二级缓存只针对以ID查询的方式生效，get、load方法。\n简述hibernate中getCurrentSession和openSession区别 getCurrentSession和openSession都是通过H的工厂去获取数据库的会话对象，\n1、getCurrentSession会绑定当前线程，而openSession不会，因为我们把hibernate交给我们的spring来管理之后，我们是有事务配置，这个有事务的线程就会绑定当前的工厂里面的每一个session，而openSession是创建一个新session。\n2、getCurrentSession事务是有spring来控制的，而openSession需要我们手动开启和手动提交事务，\n3、getCurrentSession是不需要我们手动关闭的，因为工厂会自己管理，而openSession需要我们手动关闭。\n4、而getCurrentSession需要我们手动设置 绑定事务的机制，有三种设置方式，jdbc本地的Thread、JTA、第三种是spring提供的事务管理机制org.springframework.orm.hibernate4.SpringSessionContext，而且srping默认使用该种事务管理机制，\n————————————————\n","id":0,"section":"posts","summary":"转载 · 原文链接：https://blog.csdn.net/wu1317581750/java/article/details/816629","tags":["hibernate"],"title":"Hibernate常见问题","uri":"https://bluestaree.github.io/2020/05/hibernate%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"  转载 · 原文链接：https://www.jianshu.com/p/dc1e5091a0d8\n 在大型互联网应用当中如果你的应用引入了缓存机制，那么有一个大前提就是你的业务场景上必须得接受数据的新鲜度上有可能会有一定时间的延迟。删除缓存失败是一个极小概率事件，且在不能保证所有操作100%成功的几率下，采用JOB补偿的机制是目前比较成熟的解决方案。大并发量写请求的应用，不可能去实时写DB，基本都采用队列+消息异步写DB的机制，不然会有大量的并发问题。\n缓存机制介绍 如今利用缓存机制来提高查询效率已被广泛用在各大生产环境，查询数据的一般流程如下所示\n\n在没有更新数据的情况下，数据库和缓存的数据是保持一致的，当时当要执行数据库的更新操作时，数据库和缓存就会出现不一致的情况。\n首先需要明确的是，既然系统引入缓存机制，就必须接受系统会出现数据不一致的情况发生，我们不可能完全避免，只能尽量减少不一致的时间，达到最终一致性。常见的有以下几种方案：\n 先删缓存，再更新数据库 先更新数据库，再删缓存 缓存延时双删，即先删除一次缓存，再更新数据库，延时一小段时间后再次删除缓存 监听MySQL binlog进行缓存更新  之所以缓存不采取更新操作而是直接删除，是因为高并发环境下，无论是先操作数据库还是后操作数据库，如果加上缓存更新，那就更容易导致数据库与缓存的不一致（删除缓存直接且简单得多）\n先删除缓存，再更新数据库 1、线程A删除了缓存\n2、线程B读不到缓存，然后去DB中读取了旧数据\n3、线程B将旧数据写入缓存\n4、线程A更新DB\n这样一来，DB中是新的数据，缓存中是旧的数据，造成了不一致问题。\n先更新数据库，再删除缓存 1、缓存已失效时，线程A从DB中读取到旧值\n2、线程B更新数据库，并删除了缓存\n3、线程A将旧值写入缓存\n这样一来，DB中是新的数据，缓存中是旧的数据，造成了不一致问题。\n延时双删 为解决先删除缓存，再更新数据库可能出现的问题，出现了该方案\n1、线程A删除了缓存\n2、线程B读不到缓存，然后去DB中读取了旧数据\n3、线程B将旧数据写入缓存\n4、线程A更新DB\n5、延时异步再删除缓存 上面已经分析了，如果没有第5步，会出现DB是新值，缓存是旧值的情况。加上第五步之后，4-5之间的这段时间，还是会出现数据不一致，但是一旦执行了第5步，数据又将达成最终一致性。\n","id":1,"section":"posts","summary":"转载 · 原文链接：https://www.jianshu.com/p/dc1e5091a0d8 在大型互联网应用当中如果你的应用引入了缓存机制，","tags":["缓存","数据库双写"],"title":"缓存与数据库双写一致性问题及最佳解决方案","uri":"https://bluestaree.github.io/2020/05/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E6%9C%80%E4%BD%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","year":"2020"},{"content":"  转载 · 原文链接：https://www.codesheep.cn/2018/03/29/Boot%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/\n Spring Boot使用Apache的Commons Logging作为内部的日志框架，其仅仅是一个日志接口，在实际应用中需要为该接口来指定相应的日志实现。\nSpringBt默认的日志实现是Java Util Logging，是JDK自带的日志包，此外SpringBt当然也支持Log4J、Logback这类很流行的日志实现。\n使用Spring Boot Logging插件  首先application.properties文件中加配置：  logging.level.root=INFO\r  控制器部分代码如下：  package com.hansonwang99.controller;\rimport com.hansonwang99.K8sresctrlApplication;\rimport org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RestController;\r@RestController\r@RequestMapping(\u0026quot;/testlogging\u0026quot;)\rpublic class LoggingTestController {\rprivate static Logger logger = LoggerFactory.getLogger(K8sresctrlApplication.class);\r@GetMapping(\u0026quot;/hello\u0026quot;)\rpublic String hello() {\rlogger.info(\u0026quot;test logging...\u0026quot;);\rreturn \u0026quot;hello\u0026quot;;\r}\r}\r  运行结果  运行结果\n由于将日志等级设置为INFO，因此包含INFO及以上级别的日志信息都会打印出来\n这里可以看出，很多大部分的INFO日志均来自于SpringBt框架本身，如果我们想屏蔽它们，可以将日志级别统一先全部设置为ERROR，这样框架自身的INFO信息不会被打印。然后再将应用中特定的包设置为DEBUG级别的日志，这样就可以只看到所关心的包中的DEBUG及以上级别的日志了。\n 控制特定包的日志级别  application.yml中改配置\nlogging:\rlevel:\rroot: error\rcom.hansonwang99.controller: debug\r 很明显，将root日志级别设置为ERROR，然后再将com.hansonwang99.controller包的日志级别设为DEBUG，此即：即先禁止所有再允许个别的 设置方法\n 控制器代码  package com.hansonwang99.controller;\rimport org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RestController;\r@RestController\r@RequestMapping(\u0026quot;/testlogging\u0026quot;)\rpublic class LoggingTestController {\rprivate Logger logger = LoggerFactory.getLogger(this.getClass());\r@GetMapping(\u0026quot;/hello\u0026quot;)\rpublic String hello() {\rlogger.info(\u0026quot;test logging...\u0026quot;);\rreturn \u0026quot;hello\u0026quot;;\r}\r}\r  运行结果  运行结果\n可见框架自身的INFO级别日志全部藏匿，而指定包中的日志按级别顺利地打印出来\n 将日志输出到某个文件中  logging:\rlevel:\rroot: error\rcom.hansonwang99.controller: debug\rfile: ${user.home}/logs/hello.log\r  运行结果  运行结果\n运行结果\n使用Spring Boot Logging，我们发现虽然日志已输出到文件中，但控制台中依然会打印一份，发现用org.slf4j.Logger是无法解决这个问题的\nv运行结果\n 集成Log4J日志框架  pom.xml中添加依赖   \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\r\u0026lt;exclusions\u0026gt;\r\u0026lt;exclusion\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt;\r\u0026lt;/exclusion\u0026gt;\r\u0026lt;/exclusions\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  在resources目录下添加log4j2.xml文件，内容如下：  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;appenders\u0026gt;\r\u0026lt;File name=\u0026quot;file\u0026quot; fileName=\u0026quot;${sys:user.home}/logs/hello2.log\u0026quot;\u0026gt;\r\u0026lt;PatternLayout pattern=\u0026quot;%d{HH:mm:ss,SSS} %p %c (%L) - %m%n\u0026quot;/\u0026gt;\r\u0026lt;/File\u0026gt;\r\u0026lt;/appenders\u0026gt;\r\u0026lt;loggers\u0026gt;\r\u0026lt;root level=\u0026quot;ERROR\u0026quot;\u0026gt;\r\u0026lt;appender-ref ref=\u0026quot;file\u0026quot;/\u0026gt;\r\u0026lt;/root\u0026gt;\r\u0026lt;logger name=\u0026quot;com.hansonwang99.controller\u0026quot; level=\u0026quot;DEBUG\u0026quot; /\u0026gt;\r\u0026lt;/loggers\u0026gt;\r\u0026lt;/configuration\u0026gt;\r  其他代码都保持不变  运行程序发现控制台没有日志输出，而hello2.log文件中有内容，这符合我们的预期：\n运行结果\n运行结果\n运行结果\n而且日志格式和pattern=\u0026quot;%d{HH:mm:ss,SSS} %p %c (%L) - %m%n\u0026quot;格式中定义的相匹配\n Log4J更进一步实践  pom.xml配置：  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\r\u0026lt;exclusions\u0026gt;\r\u0026lt;exclusion\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt;\r\u0026lt;/exclusion\u0026gt;\r\u0026lt;/exclusions\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  log4j2.xml配置  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;configuration status=\u0026quot;warn\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;Property name=\u0026quot;app_name\u0026quot;\u0026gt;springboot-web\u0026lt;/Property\u0026gt;\r\u0026lt;Property name=\u0026quot;log_path\u0026quot;\u0026gt;logs/${app_name}\u0026lt;/Property\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;appenders\u0026gt;\r\u0026lt;console name=\u0026quot;Console\u0026quot; target=\u0026quot;SYSTEM_OUT\u0026quot;\u0026gt;\r\u0026lt;PatternLayout pattern=\u0026quot;[%d][%t][%p][%l] %m%n\u0026quot; /\u0026gt;\r\u0026lt;/console\u0026gt;\r\u0026lt;RollingFile name=\u0026quot;RollingFileInfo\u0026quot; fileName=\u0026quot;${log_path}/info.log\u0026quot;\rfilePattern=\u0026quot;${log_path}/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log.gz\u0026quot;\u0026gt;\r\u0026lt;Filters\u0026gt;\r\u0026lt;ThresholdFilter level=\u0026quot;INFO\u0026quot; /\u0026gt;\r\u0026lt;ThresholdFilter level=\u0026quot;WARN\u0026quot; onMatch=\u0026quot;DENY\u0026quot;\ronMismatch=\u0026quot;NEUTRAL\u0026quot; /\u0026gt;\r\u0026lt;/Filters\u0026gt;\r\u0026lt;PatternLayout pattern=\u0026quot;[%d][%t][%p][%c:%L] %m%n\u0026quot; /\u0026gt;\r\u0026lt;Policies\u0026gt;\r\u0026lt;!-- 归档每天的文件 --\u0026gt;\r\u0026lt;TimeBasedTriggeringPolicy interval=\u0026quot;1\u0026quot; modulate=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;!-- 限制单个文件大小 --\u0026gt;\r\u0026lt;SizeBasedTriggeringPolicy size=\u0026quot;2 MB\u0026quot; /\u0026gt;\r\u0026lt;/Policies\u0026gt;\r\u0026lt;!-- 限制每天文件个数 --\u0026gt;\r\u0026lt;DefaultRolloverStrategy compressionLevel=\u0026quot;0\u0026quot; max=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;/RollingFile\u0026gt;\r\u0026lt;RollingFile name=\u0026quot;RollingFileWarn\u0026quot; fileName=\u0026quot;${log_path}/warn.log\u0026quot;\rfilePattern=\u0026quot;${log_path}/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log.gz\u0026quot;\u0026gt;\r\u0026lt;Filters\u0026gt;\r\u0026lt;ThresholdFilter level=\u0026quot;WARN\u0026quot; /\u0026gt;\r\u0026lt;ThresholdFilter level=\u0026quot;ERROR\u0026quot; onMatch=\u0026quot;DENY\u0026quot;\ronMismatch=\u0026quot;NEUTRAL\u0026quot; /\u0026gt;\r\u0026lt;/Filters\u0026gt;\r\u0026lt;PatternLayout pattern=\u0026quot;[%d][%t][%p][%c:%L] %m%n\u0026quot; /\u0026gt;\r\u0026lt;Policies\u0026gt;\r\u0026lt;!-- 归档每天的文件 --\u0026gt;\r\u0026lt;TimeBasedTriggeringPolicy interval=\u0026quot;1\u0026quot; modulate=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;!-- 限制单个文件大小 --\u0026gt;\r\u0026lt;SizeBasedTriggeringPolicy size=\u0026quot;2 MB\u0026quot; /\u0026gt;\r\u0026lt;/Policies\u0026gt;\r\u0026lt;!-- 限制每天文件个数 --\u0026gt;\r\u0026lt;DefaultRolloverStrategy compressionLevel=\u0026quot;0\u0026quot; max=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;/RollingFile\u0026gt;\r\u0026lt;RollingFile name=\u0026quot;RollingFileError\u0026quot; fileName=\u0026quot;${log_path}/error.log\u0026quot;\rfilePattern=\u0026quot;${log_path}/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log.gz\u0026quot;\u0026gt;\r\u0026lt;ThresholdFilter level=\u0026quot;ERROR\u0026quot; /\u0026gt;\r\u0026lt;PatternLayout pattern=\u0026quot;[%d][%t][%p][%c:%L] %m%n\u0026quot; /\u0026gt;\r\u0026lt;Policies\u0026gt;\r\u0026lt;!-- 归档每天的文件 --\u0026gt;\r\u0026lt;TimeBasedTriggeringPolicy interval=\u0026quot;1\u0026quot; modulate=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;!-- 限制单个文件大小 --\u0026gt;\r\u0026lt;SizeBasedTriggeringPolicy size=\u0026quot;2 MB\u0026quot; /\u0026gt;\r\u0026lt;/Policies\u0026gt;\r\u0026lt;!-- 限制每天文件个数 --\u0026gt;\r\u0026lt;DefaultRolloverStrategy compressionLevel=\u0026quot;0\u0026quot; max=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;/RollingFile\u0026gt;\r\u0026lt;/appenders\u0026gt;\r\u0026lt;loggers\u0026gt;\r\u0026lt;root level=\u0026quot;info\u0026quot;\u0026gt;\r\u0026lt;appender-ref ref=\u0026quot;Console\u0026quot; /\u0026gt;\r\u0026lt;appender-ref ref=\u0026quot;RollingFileInfo\u0026quot; /\u0026gt;\r\u0026lt;appender-ref ref=\u0026quot;RollingFileWarn\u0026quot; /\u0026gt;\r\u0026lt;appender-ref ref=\u0026quot;RollingFileError\u0026quot; /\u0026gt;\r\u0026lt;/root\u0026gt;\r\u0026lt;/loggers\u0026gt;\r\u0026lt;/configuration\u0026gt;\r  控制器代码：  package com.hansonwang99.controller;\rimport org.apache.logging.log4j.LogManager;\rimport org.apache.logging.log4j.Logger;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RestController;\r@RestController\r@RequestMapping(\u0026quot;/testlogging\u0026quot;)\rpublic class LoggingTestController {\rprivate final Logger logger = LogManager.getLogger(this.getClass());\r@GetMapping(\u0026quot;/hello\u0026quot;)\rpublic String hello() {\rfor(int i=0;i\u0026lt;10_0000;i++){\rlogger.info(\u0026quot;info execute index method\u0026quot;);\rlogger.warn(\u0026quot;warn execute index method\u0026quot;);\rlogger.error(\u0026quot;error execute index method\u0026quot;);\r}\rreturn \u0026quot;My First SpringBoot Application\u0026quot;;\r}\r}\r  运行结果  运行结果\n运行结果\n运行结果\n日志会根据不同的级别存储在不同的文件，当日志文件大小超过2M以后会分多个文件压缩存储，生产环境的日志文件大小建议调整为20-50MB。\n","id":2,"section":"posts","summary":"转载 · 原文链接：https://www.codesheep.cn/2018/03/29/Boot%E6%97%A5%E5%BF%97%E6%","tags":["Springboot"],"title":"Springboot日志配置","uri":"https://bluestaree.github.io/2020/04/springboot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/","year":"2020"},{"content":" 记录一个坑，我现在所用的MySQL数据库的版本是8.019，在尝试使用Navicat连接数据库时，出现1251错误\n解决方法： 进入docker容器修改MySQL的root用户加密规则\n ALTER USER \u0026lsquo;root\u0026rsquo;@\u0026lsquo;localhost\u0026rsquo; IDENTIFIED WITH mysql_native_password BY \u0026lsquo;password\u0026rsquo;; #修改加密规则 ALTER USER \u0026lsquo;root\u0026rsquo;@\u0026lsquo;localhost\u0026rsquo; IDENTIFIED BY \u0026lsquo;password\u0026rsquo; PASSWORD EXPIRE NEVER; #更新一下用户的密码 FLUSH PRIVILEGES; #刷新权限  \u0026lsquo;root\u0026rsquo; 为你自己定义的用户名\n\u0026lsquo;localhost\u0026rsquo; 指的是用户开放的IP，可以是\u0026rsquo;localhost\u0026rsquo;(仅本机访问，相当于127.0.0.1)，可以是具体的\u0026rsquo;...'(具体某一IP)，也可以是 \u0026lsquo;%\u0026rsquo; (所有IP均可访问)\n\u0026lsquo;password\u0026rsquo; 是你想使用的用户密码\n","id":3,"section":"posts","summary":"记录一个坑，我现在所用的MySQL数据库的版本是8.019，在尝试使用Navicat连接数据库时，出现1251错误 解决方法： 进入docker","tags":null,"title":"Navicat连接MySQL出现1251错误","uri":"https://bluestaree.github.io/2020/04/navicat-1251%E9%94%99%E8%AF%AF/","year":"2020"},{"content":" 最近在学习中遇到了新的包管理工具 - Gradle 。\n上网查询了下Gradle 的依赖方式，方便与Maven区分对比 。\n 转载 · 原文链接：https://blog.csdn.net/zyt_524744325/article/details/86535463\n 依赖配置-Gradle 目前Gradle版本支持的依赖配置有：implementation、api、compileOnly、runtimeOnly和annotationProcessor，已经废弃的配置有：compile、provided、apk、providedCompile。此外依赖配置还可以加一些配置项，例如AndroidTestImplementation、debugApi等等。\n implementation  与compile对应，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。使用这个配置，可以显著提升构建时间，因为它可以减少重新编译的module的数量。建议，尽量使用这个依赖配置。\n api  与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。\n compileOnly  与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。\n runtimeOnly  与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。\n annotationProcessor  与compile对应，用于注解处理器的依赖配置，这个没用过。\n 依赖配置-Maven  compile  默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。\n test  该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。\n runtime  依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。\n此类的驱动都是为runtime的类库。\n provided  该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。\n system  使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。\n import  这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。\n","id":4,"section":"posts","summary":"最近在学习中遇到了新的包管理工具 - Gradle 。 上网查询了下Gradle 的依赖方式，方便与Maven区分对比 。 转载 · 原文链接：https://blog","tags":["Maven","Gradle"],"title":"Maven,Gradle依赖","uri":"https://bluestaree.github.io/2020/04/mavengradle%E4%BE%9D%E8%B5%96/","year":"2020"},{"content":"  转载 · 原文链接：https://blog.csdn.net/CSDN_Ty/article/details/98877883\n 本文的内容主要想解决一下几个问题：\n equals() 和 == 的作用是什么？ equals() 和 == 的区别是什么？ hashCode()的作用是什么？ hashCode()与equals()之间有什么联系？  equals() 和 == 的作用  == 是用来判断两个对象是否为同一个对象，通过判断两个对象的内存地址来区分它们是否相等。 equals() 是用来判断两个对象是否相等，equals()定义在Object类中，所有类都继承了该方法。  从源码可以看出，默认情况下，equals与==没有区别，equals就是调用的==来进行判断。\npublic boolean equals(Object obj) {\rreturn (this == obj);\r}\r 所以，通常我们都会重写equals方法：两对象内容相等，则返回true，否则返回false。举例：\n①没有重写equals()方法时：\npublic class Test {\r@AllArgsConstructor\r@Setter\r@Getter\rpublic static class Student {\rprivate String name;\rprivate int age;\r}\rpublic static void main(String[] args) {\rStudent stu1 = new Student(\u0026quot;ye17186\u0026quot;, 18);\rStudent stu2 = new Student(\u0026quot;ye17186\u0026quot;, 18);\rSystem.out.println(\u0026quot;stu1.equals(stu2): \u0026quot; + stu1.equals(stu2));\r}\r}\r 输出结果：\n\n解析：\n由于stu1、stu2都是直接new出来的对象，它们指向两块不同的内存地址，在未重写equals方法的情况下，调用equals()方法其实就是调用==，比较的是他们的内存地址是否相同，所以这里打印的结果的false。\n②重写equals()方法时：\npublic class Test {\r@AllArgsConstructor\r@Setter\r@Getter\rpublic static class Student {\rprivate String name;\rprivate int age;\r@Override\rpublic boolean equals(Object o) {\rif (this == o) {\rreturn true;\r}\rif (o == null || getClass() != o.getClass()) {\rreturn false;\r}\rStudent student = (Student) o;\rreturn name.equals(student.getName()) \u0026amp;\u0026amp; age == student.age;\r}\r}\rpublic static void main(String[] args) {\rStudent stu1 = new Student(\u0026quot;ye17186\u0026quot;, 18);\rStudent stu2 = new Student(\u0026quot;ye17186\u0026quot;, 18);\rSystem.out.println(\u0026quot;stu1.equals(stu2): \u0026quot; + stu1.equals(stu2));\r}\r}\r 输出结果：\n\n解析：\n重写equals方法后，就会使用equals方法内的逻辑来判断是否相等，例子中直接比较了name和age是否相等，stu1和stu2两个对象，他们的name都是ye17186，age都是18，所以这里输出的结果是true。\nequals()与==的区别 上面已经解析过了，从设计上说==是用来判断是否为同一个对象，equals()用来判断两个对象是否相等。如果我们没有重写equals()方法，那么二者其实是等价的。但一般我们会重写equals()方法，这样会按照我们重写的逻辑来判断两个对象是否相等。\nhashCode的作用  hashCode()的作用是获取哈希码，也成为了散列码，它实际上返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode()定义在java.lang.Object中，这意味着JAVA中任何类都有这个函数。 虽然每个JAVA类都有hashCode函数，但是仅仅当创建某个“类的散列表”时，该类的hashCode()才有用（作用是确定该类的每一个对象在散列表中的位置），其他情况下（例如：创建类的单个对象，或者创建类的对象数组等），类的hashCode()没有作用。 上面的散列表，指的是JAVA集合中本质是散列表的类，如HashMap、HashTable、HashSet。 也就是说，hashCode()在散列表中有用，在其他情况下没用。在散列表中hashCode()用于获取对象的散列码，从而确定该对象在散列表中的位置。 如果两个对象相等，他们的散列码一定相等；但是如果散列码相等，它们不一定相等  hashCode()与equals之间的联系 在非”本质是散列表的类”中，两者没有任何关系。而在”本质是散列表的类”中，在HashSet中，如果两个对象的hashCode相同，即使equals不等，它们在集合中也只会存储一个。\n","id":5,"section":"posts","summary":"转载 · 原文链接：https://blog.csdn.net/CSDN_Ty/article/details/98877883 本文的内容主要想","tags":["hashCode","equals"],"title":"hashCode和equals的相关问题","uri":"https://bluestaree.github.io/2020/04/hashcode%E5%92%8Cequals%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","year":"2020"},{"content":" 字符集\n先来说说什么是字符集把，字符集就是将二进制字节码转换为某种特殊字符的映射集合，每个字符集都有其特定的校验规则\nTIP : 1 Byte = 8 bit\n常见的字符集\n ASCII (American Standard Code for Information Interchange,美国信息交换标准代码) .  - 7 bit来表示一个字符，共计可以表示2^7 = 128 字符\n ISO-8859-1 （ASCII 升级版），共计可以表示2^8 = 256 字符  - 8 bit来表示一个字符\n 国内字符编码标准  GB2312 两个字节表示一个汉字 GBK (GB2312 升级版) GB18030 (简体完全版) BIG5 (台湾繁体)     因为这些字符集都只能转换特定语言的字符，因此就出现了我们所熟悉\n统一字符编码标准\nUnicode\n 采用两个字节表示一个字符，世界所有字符的集合 存储空间占用较大，特别是英文文档  Unicode的实现方式\nUTF (Unicode Translation Format)\n##注意 Unicode是编码方式 而UTF是Unicode的实现方式之一\nUTF家族\n  UTF-32\n  UTF-16LE(little endian) , UTF-16BE(big endian)\n  - 会在文开头中加入一个表示大端或小端的符号 (ZERO WIDTH NO-BREAK SPACE , 本身并不存在)\n- 依旧会存在存储空间占用大的问题\n UTF-8 (最常用)  - 采用变长字节表示形式\n- 在windows下可能会出现带BOM(Byte Order Mark)头 (不存在,同上) 的UTF-8编码方式,用于区别文件是大端存储还是小端存储,\n而这对于UTF-8 是不需要的，一些软件根本不考虑此问题，因此在解析时遇到BOM头可能会出现解析异常\n","id":6,"section":"posts","summary":"字符集 先来说说什么是字符集把，字符集就是将二进制字节码转换为某种特殊字符的映射集合，每个字符集都有其特定的校验规则 TIP : 1 Byte = 8 bit 常见的字符集","tags":["字符集","charset"],"title":"字符集编码","uri":"https://bluestaree.github.io/2020/04/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81/","year":"2020"},{"content":"  Spring Security 是spring项目之中的一个安全模块，可以非常方便与spring项目无缝集成。特别是在spring boot项目中加入spring security更是十分简单。本篇主要介绍spring security的验证与授权流程，以及spring security在web应用中的相关配置。\n ","id":7,"section":"posts","summary":"Spring Security 是spring项目之中的一个安全模块，可以非常方便与spring项目无缝集成。特别是在spring boot项目中加入spring secu","tags":["SpringSecurity"],"title":"SpringSecurity流程与配置","uri":"https://bluestaree.github.io/2020/04/spring-security%E6%B5%81%E7%A8%8B%E4%B8%8E%E9%85%8D%E7%BD%AE/","year":"2020"},{"content":"  转载 · 原文链接：https://blog.csdn.net/qw463800202/article/details/103221651\n 一、动态sql使用 1.1、在项目中涉及多个动态查询条件，一般我们是通过 where 1 = 1，这样可以处理where后面对应条件全空的情况，我们可以使用标签，该标签可以自动处理,主要是当我们的sql查询条件以AND和OR结尾时，会自动去除，如\n\u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;keyword != null\u0026quot;\u0026gt; and title like concat('%',trim(#{keyword}),'%') \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt;\r\u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;name != null\u0026quot;\u0026gt; or name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;keyword != null\u0026quot;\u0026gt; or title like concat('%',trim(#{keyword}),'%') \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt;\r 1.2、在项目中涉及多个动态update条件时，传统的项目需要我们去除最后一个条件的逗号，但是在mybatis中我们可以使用标签，如\nUPDATE user\r\u0026lt;set\u0026gt;\r\u0026lt;if test ='null != name'\u0026gt;name = #{name},\u0026lt;/if\u0026gt;\r\u0026lt;if test ='null != email'\u0026gt;email = #{email},\u0026lt;/if\u0026gt;\r\u0026lt;if test ='null != headUrl'\u0026gt;head_url = #{headUrl},\u0026lt;/if\u0026gt;\r\u0026lt;if test ='null != linkData'\u0026gt;link_data = #{linkData},\u0026lt;/if\u0026gt;\r\u0026lt;if test ='null != createTime'\u0026gt;create_time = #{createTime},\u0026lt;/if\u0026gt;\r\u0026lt;if test ='null != updateTime'\u0026gt;update_time = #{updateTime}\u0026lt;/if\u0026gt;\r\u0026lt;/set\u0026gt;\r ​ 1.3、动态if else语句，在mybatis中使用choose、when、otherwise来处理，如下代码\nmybatis 中 SQL 写在mapper.xml文件中，而xml解析 \u0026lt; 、\u0026gt;、\u0026lt;=、\u0026gt;= 时会出错，这时应该使用转义写法，如下\n   \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= \u0026amp; ' \u0026quot;     \u0026amp;lt; \u0026amp;lt;= \u0026amp;gt; \u0026amp;gt;= \u0026amp;amp; \u0026amp;apos; \u0026amp;quot;    三、mybatis循环标签 3.1、循环查询in语句，代码如下\n \u0026lt;select id=\u0026quot;findBy\u0026quot; resultMap=\u0026quot;BaseResultMap\u0026quot;\u0026gt;\rselect * from user where user_id in\r\u0026lt;foreach item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; collection=\u0026quot;list\u0026quot; open=\u0026quot;(\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;)\u0026quot;\u0026gt;\r#{item}\r\u0026lt;/foreach\u0026gt;\r\u0026lt;/select\u0026gt;\r 3.2、批量插入使用循环,代码如下\n\u0026lt;insert id=\u0026quot;insertList\u0026quot; parameterType=\u0026quot;java.util.List\u0026quot;\u0026gt;\rinsert into user\r( name,sex,email,remark)\rvalues\r\u0026lt;foreach collection=\u0026quot;list\u0026quot; item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt;\r(\r#{item.name},\r#{item.sex},\r#{item.email},\r#{item.remark}\r)\r\u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;  四、重复的sql片段整合在一起使用include标签 定义：\r\u0026lt;sql id=\u0026quot;Base_Column_List\u0026quot; \u0026gt; id, name, url, priority, logo, img \u0026lt;/sql\u0026gt; 引用：\r\u0026lt;include refid=\u0026quot;Base_Column_List\u0026quot; /\u0026gt;  ————————————————\n","id":8,"section":"posts","summary":"转载 · 原文链接：https://blog.csdn.net/qw463800202/article/details/103221651 一、动","tags":["Mybatis"],"title":"Mybatis常用语法汇总","uri":"https://bluestaree.github.io/2020/03/mybatis%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/","year":"2020"},{"content":"  转载 · 原文链接：https://www.runoob.com/java/java8-new-features.html\n java 8 新特性 Java8 新增了非常多的特性，我们主要讨论以下几个：\n Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用  先来看看排序方式的对比把\n// 使用 java 7 排序\rprivate void sortUsingJava7(List\u0026lt;String\u0026gt; names){ Collections.sort(names, new Comparator\u0026lt;String\u0026gt;() {\r@Override\rpublic int compare(String s1, String s2) {\rreturn s1.compareTo(s2);\r}\r});\r}\r// 使用 java 8 排序\rprivate void sortUsingJava8(List\u0026lt;String\u0026gt; names){\rCollections.sort(names, (s1, s2) -\u0026gt; s1.compareTo(s2));\r}\r 怎么样，是不是感觉代码简化了不少，让我们继续深入学习java8的那些新特性\nLambda 表达式实例 Lambda 表达式的简单例子:\n// 1. 不需要参数,返回值为 5 () -\u0026gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -\u0026gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -\u0026gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -\u0026gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -\u0026gt; System.out.print(s)\r 使用 Lambda 表达式需要注意以下两点：\n Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。 Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。  Java 8 方法引用 方法引用通过方法的名字来指向一个方法。\n方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n方法引用使用一对冒号 :: 。\n **构造器引用：**它的语法是Class::new，或者更一般的Class\u0026lt; T \u0026gt;::new实例如下：  final Car car = Car.create( Car::new );\rfinal List\u0026lt; Car \u0026gt; cars = Arrays.asList( car );\r  **静态方法引用：**它的语法是Class::static_method，实例如下：  cars.forEach( Car::collide );\r  **特定类的任意对象的方法引用：**它的语法是Class::method实例如下：  cars.forEach( Car::repair );\r  **特定对象的方法引用：**它的语法是instance::method实例如下：  final Car police = Car.create( Car::new );\rcars.forEach( police::follow );\r Java 8 Stream Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。\nStream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\nStream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\n元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。\n生成流\n在 Java 8 中, 集合接口有两个方法来生成流：\n stream() − 为集合创建串行流。 parallelStream() − 为集合创建并行流。  List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;);\rList\u0026lt;String\u0026gt; filtered = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.toList());\r  forEach\nStream 提供了新的方法 \u0026lsquo;forEach\u0026rsquo; 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：\nRandom random = new Random();\rrandom.ints().limit(10).forEach(System.out::println);\r  map\nmap 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);\r// 获取对应的平方数\rList\u0026lt;Integer\u0026gt; squaresList = numbers.stream().map( i -\u0026gt; i*i).distinct().collect(Collectors.toList());\r  filter\nfilter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：\nList\u0026lt;String\u0026gt;strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;);\r// 获取空字符串的数量\rlong count = strings.stream().filter(string -\u0026gt; string.isEmpty()).count();\r  limit\nlimit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：\nRandom random = new Random();\rrandom.ints().limit(10).forEach(System.out::println);\r  sorted\nsorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：\nRandom random = new Random();\rrandom.ints().limit(10).sorted().forEach(System.out::println);\r  并行（parallel）程序\nparallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：\nList\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;);\r// 获取空字符串的数量\rint count = strings.parallelStream().filter(string -\u0026gt; string.isEmpty()).count();\r 我们可以很容易的在顺序运行和并行直接切换。\n Collectors\nCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：\nList\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;);\rList\u0026lt;String\u0026gt; filtered = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.toList());\rSystem.out.println(\u0026quot;筛选列表: \u0026quot; + filtered);\rString mergedString = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.joining(\u0026quot;, \u0026quot;));\rSystem.out.println(\u0026quot;合并字符串: \u0026quot; + mergedString);\r  统计\n另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);\rIntSummaryStatistics stats = numbers.stream().mapToInt((x) -\u0026gt; x).summaryStatistics();\rSystem.out.println(\u0026quot;列表中最大的数 : \u0026quot; + stats.getMax());\rSystem.out.println(\u0026quot;列表中最小的数 : \u0026quot; + stats.getMin());\rSystem.out.println(\u0026quot;所有数之和 : \u0026quot; + stats.getSum());\rSystem.out.println(\u0026quot;平均数 : \u0026quot; + stats.getAverage());\r 默认方法 Java 8 新增了接口的默认方法。\n简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。\n我们只需在方法名前面加个 default 关键字即可实现默认方法。\n语法\n默认方法语法格式如下：\npublic interface Vehicle {\rdefault void print(){\rSystem.out.println(\u0026quot;我是一辆车!\u0026quot;);\r}\r}\r Java 8 函数式接口 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。\n函数式接口可以被隐式转换为 lambda 表达式。\nLambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。\n如定义了一个函数式接口如下：\n@FunctionalInterface\rinterface GreetingService {\rvoid sayMessage(String message);\r}\r 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：\nGreetingService greetService1 = message -\u0026gt; System.out.println(\u0026quot;Hello \u0026quot; + message);\r Java 8 Optional 类 Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\nOptional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。\nOptional 类的引入很好的解决空指针异常。\n类方法    序号 方法 \u0026amp; 描述     1 static Optional empty() 返回空的 Optional 实例。   2 boolean equals(Object obj) 判断其他对象是否等于 Optional。   3 Optional filter(Predicate predicate) 如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。   4 Optional flatMap(Function\u0026gt; mapper) 如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional   5 T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException   6 int hashCode() 返回存在值的哈希码，如果值不存在 返回 0。   7 void ifPresent(Consumer consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情。   8 boolean isPresent() 如果值存在则方法会返回true，否则返回 false。   9 Optional map(Function mapper) 如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。   10 static Optional of(T value) 返回一个指定非null值的Optional。   11 static Optional ofNullable(T value) 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。   12 T orElse(T other) 如果存在该值，返回值， 否则返回 other。   13 T orElseGet(Supplier other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。   14 T orElseThrow(Supplier exceptionSupplier) 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常   15 String toString() 返回一个Optional的非空字符串，用来调试    注意： 这些方法是从 java.lang.Object 类继承来的。\nJava 8 日期时间 API Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。\n在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：\n 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。 时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。  Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：\n Local(本地) − 简化了日期时间的处理，没有时区的问题。 Zoned(时区) − 通过制定的时区处理日期时间。  新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n本地化日期时间 API\nLocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：\nJava8Tester.java 文件\nimport java.time.LocalDate;\rimport java.time.LocalTime;\rimport java.time.LocalDateTime;\rimport java.time.Month;\rpublic class Java8Tester {\rpublic static void main(String args[]){\rJava8Tester java8tester = new Java8Tester();\rjava8tester.testLocalDateTime();\r}\rpublic void testLocalDateTime(){\r// 获取当前的日期时间\rLocalDateTime currentTime = LocalDateTime.now();\rSystem.out.println(\u0026quot;当前时间: \u0026quot; + currentTime);\rLocalDate date1 = currentTime.toLocalDate();\rSystem.out.println(\u0026quot;date1: \u0026quot; + date1);\rMonth month = currentTime.getMonth();\rint day = currentTime.getDayOfMonth();\rint seconds = currentTime.getSecond();\rSystem.out.println(\u0026quot;月: \u0026quot; + month +\u0026quot;, 日: \u0026quot; + day +\u0026quot;, 秒: \u0026quot; + seconds);\rLocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);\rSystem.out.println(\u0026quot;date2: \u0026quot; + date2);\r// 12 december 2014\rLocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);\rSystem.out.println(\u0026quot;date3: \u0026quot; + date3);\r// 22 小时 15 分钟\rLocalTime date4 = LocalTime.of(22, 15);\rSystem.out.println(\u0026quot;date4: \u0026quot; + date4);\r// 解析字符串\rLocalTime date5 = LocalTime.parse(\u0026quot;20:15:30\u0026quot;);\rSystem.out.println(\u0026quot;date5: \u0026quot; + date5);\r}\r}\r 执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester\r当前时间: 2016-04-15T16:55:48.668\rdate1: 2016-04-15\r月: APRIL, 日: 15, 秒: 48\rdate2: 2012-04-10T16:55:48.668\rdate3: 2014-12-12\rdate4: 22:15\rdate5: 20:15:30\r ","id":9,"section":"posts","summary":"转载 · 原文链接：https://www.runoob.com/java/java8-new-features.html java 8 新特性 Java8 新增了非常","tags":["jdk8"],"title":"JDK 8 的那些新特性","uri":"https://bluestaree.github.io/2020/03/jdk-8%E7%9A%84%E9%82%A3%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/","year":"2020"},{"content":" 原反补的相互转换 今天在学习算法时遇到了这个问题，然后大脑就突然宕机。什么情况w(ﾟДﾟ)w！\n在此上网查询资料后记录下，\n 转载 · 原文链接：https://blog.csdn.net/chaochaoaiyuer/article/details/82868761\n 原码转反码\n 符号位不变，数值位按位取反  反码转原码\n 符号位不变，数值位按位取反  原码转补码\n  正数：正数的补码就是其本身。\n  负数：在原码的基础上，符号位不变，其余的各个位取反，最后+1.（反码+1）\n  补码转原码\n 符号位不变，数值位按位取反，末位再加１．即补码的补码等于原码，  已知补码，求原码的负数的补码\n 符号位和数值位都按位取反，末位再加１   总结：  计算机在进行减法时，都是在做加法运算。 正数原码、反码、补码是一样。 负数的反码，在原码的基础上，符号位不变，其余的各个位取反（1变0，0变1）。 负数的补码，就是反码+1.   ","id":10,"section":"posts","summary":"原反补的相互转换 今天在学习算法时遇到了这个问题，然后大脑就突然宕机。什么情况w(ﾟДﾟ)w！ 在此上网查询资料后记录下， 转载 · 原文链接：htt","tags":null,"title":"原码、反码和补码","uri":"https://bluestaree.github.io/2020/03/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/","year":"2020"},{"content":" 排序分类   内部排序：将所有需要处理的数据加载到内部存储器中进行排序 (使用内存)\n  插入排序\n 直接插入排 希尔排序    选择排序\n 简单选择排序 堆排序    交换排序\n 冒泡排序 快速排序    归并排序\n  基数排序\n    外部排序：数据量过大时，需要借助外部存储进行排序 (内存和外存相结合)\n   算法效率 = 时间复杂度 + 空间复杂度  时间复杂度：无论多少行代码，代码所执行的次数  常见的有: 常数阶O(1) ,对数阶O(og2N) ,线性阶O(n),线性对数阶O(n *log2n),平方阶O(n^2)\n 空间复杂度 :该算法所耗费的存储空间  常见算法对比\n看情况选择合适的算法(数据规模：n的大小)，\n 常见排序算法 冒泡排序\n 时间复杂度O(n^2)  对数组中的数据两两比较，将较大的数向后移动，共需要排序array.legth -1次(第一次确定最大的数，第二次确定倒数第二大的数，以此类推)\n优化: 如果在某次排序中，没有发送一次交换，可以提前结束。\n选择排序  时间复杂度O(n^2)  第一次，假定第一个数的值最小 ， 依次与后面的数比较，并记录其更小数的索引和值，最后交换位置(确定最小)，第二次从数组的第二个索引位置开始依次对比，依旧找出最小的与之交换，以此类推,共需要排序array.legth -1次\n因为交换次数少，效率会比冒泡高\n直接插入排序 第一次排序时，将待排序的数组的第一个元素看成一个有序表，其他元素为无序表。第二次排序时，将无序表的一个元素取出放入有序表中，并比较放入适当的位置，以此类推\n希尔排序  (缩小增量排序) 插入排序的优化版本  分为交换法(类似冒泡排序，速度很慢) 和 移位法(结合插入排序，速度很快)\n利用将整体拆分为多组排序的，最后整合的思想，\n首先，根据数据的长度/2 = n，分n组但元素量较小的数组进行排序。此后依次按照上一次分组的结果n/2 进行新的分组排序，每次增量(步长)都会减小，但每组元素数量增加，直到最后一次,增量(步长)为1，相当于对整个数据进行排序(此时由于之前已经对将整个数组根据增量拆分为多组并分别排序，已经有了一定的顺序，无限接近有序)，因此最后一次只需要进行善后处理，)\n快速排序\n是对冒泡排序的一种改进 ，使用递归完成\n首先，找一个数作为基准，将整个数组分割为两个数组，\n以从小到大排序为例，其中第一个数组的值都要比第二个数组值小同时也是小于或等于基准值，继续在这两组元素中找一个基准值，继续分割，依次类推，使用递归处理，直到分割的每一个数组只剩一个元素，将每一个元素和基准数按照顺序组合在一起就是一个有序数组\n归并排序\n经典分治策略\n使用递归完成排序 ，排序次数 length-1 次\n首先，将一个数组按照中间索引等量拆分为两数组，再对这两个数组的中间索引进行拆分，知道每组元素只剩1个。\n通过递归调用，开始合并拆分的数组，并在合并时进行排序，将结果存储在一个临时数组中,每次排序后将结果都复制到原来数组覆盖，最后的结果就是一个有序的数组。 根据递归调用的原理，首先会将处于栈顶的只含单元素的数组进行合并排序，依次类推，直到最后一次合并，形成完整的数组进行最后的排序\n基数排序 - (桶排序)\n空间换时间，占用内存大 稳定性排序\n稳定性排序\u0026mdash;-如果排序的数组中有多个相同的数，那么在排序后，这些相同的数也会按照原来的先后位置排列（相对位置不变），。 如 r[i]=r[j] 且原数组 r[i]在r[j]之前，那么排序后，r[i]的位置仍在r[j]之前\n每一次排序，将数组中的每个数，取出其的个位的数，放入十个桶中(序号0-9表示指定位数的值)， 然后按桶的序号，依次取出，并赋给原数组。完成第一次后， 取出百位，继续上述步骤(取决于数据中最大值的位数)，\n排序次数，该数组中数据最大值的位数\n堆排序\n","id":11,"section":"posts","summary":"排序分类 内部排序：将所有需要处理的数据加载到内部存储器中进行排序 (使用内存) 插入排序 直接插入排 希尔排序 选择排序 简单选择排序 堆排序 交换排序 冒泡","tags":["算法"],"title":"排序算法","uri":"https://bluestaree.github.io/2020/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","year":"2020"},{"content":" 常用的查找算法： 1）顺序(线性)查找\n- 有序与无序数组均可。逐一比对，发现相同值，就返回\n 2）二分查找/折半查找\n前提：必须为有序数组\n 3）插值查找\n前提：必须为有序数组\n求中值公式\n 4）斐波那契查找 (黄金分割法)\n前提：必须为有序数组\n","id":12,"section":"posts","summary":"常用的查找算法： 1）顺序(线性)查找 - 有序与无序数组均可。逐一比对，发现相同值，就返回 2）二分查找/折半查找 前提：必须为有序数组 3）插值查找","tags":["算法"],"title":"查找算法","uri":"https://bluestaree.github.io/2020/03/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","year":"2020"},{"content":" 图的遍历方式 ：\n  深度优先(DFS) 广度优先(BFS)   代码实现\n首先创建一个自定义的Graph对象，其中包含一个二维数组表示图结构\n//创建图对象\rGraph graph = new Graph(n);\r//循环的添加顶点\rfor(String vertex: Vertexs) {\rgraph.insertVertex(vertex);\r}\r//添加边\r//A-B A-C B-C B-D B-E graph.insertEdge(0, 1, 1); // A-B\rgraph.insertEdge(0, 2, 1); // A-C\rgraph.insertEdge(1, 2, 1); // B-C\rgraph.insertEdge(1, 3, 1); // B-D\rgraph.insertEdge(1, 4, 1); // B-E\r //添加边\r/**\r* * @param v1 表示点的下标即使第几个顶点 \u0026quot;A\u0026quot;-\u0026quot;B\u0026quot; \u0026quot;A\u0026quot;-\u0026gt;0 \u0026quot;B\u0026quot;-\u0026gt;1\r* @param v2 第二个顶点对应的下标\r* @param weight 表示权值\r*/\rpublic void insertEdge(int v1, int v2, int weight) {\redges[v1][v2] = weight;\redges[v2][v1] = weight;\rnumOfEdges++;\r}\r 获取下一个相邻的节点，以及次相邻的节点 方法\n//得到第一个邻接结点的下标 w /**\r* * @param index * @return 如果存在就返回对应的下标，否则返回-1\r*/\rpublic int getFirstNeighbor(int index) {\rfor(int j = 0; j \u0026lt; vertexList.size(); j++) {\rif(edges[index][j] \u0026gt; 0) {\rreturn j;\r}\r}\rreturn -1;\r}\r//根据前一个邻接结点的下标来获取下一个邻接结点\rpublic int getNextNeighbor(int v1, int v2) {\rfor(int j = v2 + 1; j \u0026lt; vertexList.size(); j++) {\rif(edges[v1][j] \u0026gt; 0) {\rreturn j;\r}\r}\rreturn -1;\r}\r //深度优先遍历算法\r//i 第一次就是 0\rprivate void dfs(boolean[] isVisited, int i) {\r//首先我们访问该结点,输出\rSystem.out.print(getValueByIndex(i) + \u0026quot;-\u0026gt;\u0026quot;);\r//将结点设置为已经访问\risVisited[i] = true;\r//查找结点i的第一个邻接结点w\rint w = getFirstNeighbor(i);\rwhile(w != -1) {//说明有\rif(!isVisited[w]) {\rdfs(isVisited, w);\r}\r//如果w结点已经被访问过\rw = getNextNeighbor(i, w);\r}\r}\r //广度优先遍历算法\rprivate void bfs(boolean[] isVisited, int i) {\rint u ; // 表示队列的头结点对应下标\rint w ; // 邻接结点w\r//队列，记录结点访问的顺序\rLinkedList queue = new LinkedList();\r//访问结点，输出结点信息\rSystem.out.print(getValueByIndex(i) + \u0026quot;=\u0026gt;\u0026quot;);\r//标记为已访问\risVisited[i] = true;\r//将结点加入队列\rqueue.addLast(i);\rwhile( !queue.isEmpty()) {\r//取出队列的头结点下标\ru = (Integer)queue.removeFirst();\r//得到第一个邻接结点的下标 w w = getFirstNeighbor(u);\rwhile(w != -1) {//找到\r//是否访问过\rif(!isVisited[w]) {\r//访问该结点\rSystem.out.print(getValueByIndex(w) + \u0026quot;=\u0026gt;\u0026quot;);\r//标记已经访问\risVisited[w] = true;\r//入队\rqueue.addLast(w);\r}\r//以u为前驱点，找w后面的下一个邻结点\rw = getNextNeighbor(u, w); }\r}\r}   结果展示\n","id":13,"section":"posts","summary":"图的遍历方式 ： 深度优先(DFS) 广度优先(BFS) 代码实现 首先创建一个自定义的Graph对象，其中包含一个二维数组表示图结构 //创建图对象 Graph","tags":["数据结构"],"title":"图的遍历方式","uri":"https://bluestaree.github.io/2020/03/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","year":"2020"},{"content":" 前言\n  数据结构是计算机存储、组织数据的方式 数据结构包括，线性结构和非线性结构 线性结构：特点是数据元素之间存在一对一的线性关系，如数据a[0]与a[1]各表示一个数据  存储方式，分为顺序存储结构(数组,在内存中存储的地址是连续的) ，和链式存储结构(链表)。常见的线性结构有：数组，队列，链表和栈\n 非线性结构:包括二维数组，多维数组，广义表，树结构，图结构   稀疏数组\n当一个数组中大部分元素为0，或者为同一个值时，可以使用稀疏数组来保存该数组，既将数组中没有意义的数值进行压缩，方便保存。\n方法;1.记录数组一共有几行几列，有多少个不同的值\n2.把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小存储的规模\n哈希表\n散列函数(Hash table ,也称哈希表) 通过关键码值 映射到表中的一个位置来访问记录，可用作缓存\n树结构\n为何需要树结构存储数据？\n数组增删慢(需要整体移动)，查询快(索引定位)\n链表增删快，查询慢\n 二叉树  顺序存储二叉树  将一个有序的数组，通过特定的索引值，实现树结构\n线索化二叉树  有效利用所有节点的左右指针\n二叉排序数  平衡二叉树  多叉树  23树，234树等都属于多叉树\nB树、B+树和B*树  图  ","id":14,"section":"posts","summary":"前言 数据结构是计算机存储、组织数据的方式 数据结构包括，线性结构和非线性结构 线性结构：特点是数据元素之间存在一对一的线性关系，如数据a[0]与","tags":["数据结构"],"title":"数据结构","uri":"https://bluestaree.github.io/2020/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","year":"2020"},{"content":"  转载 · 原文链接：https://www.codesheep.cn/2018/09/04/springboot-startup-process/\n 结合 SpringBoot 2.0的源码，来看看SpringBoot应用程序的启动流程！\n概述 说到接触 SpringBoot 伊始，给我第一映像最深的是有两个关键元素：\n对照上面的典型代码，这个两个元素分别是：\n @SpringBootApplication SpringApplication 以及 run() 方法  那么本文我们就来看看这个 SpringApplication 以及 run() 方法 到底是个什么鬼，它背后又隐藏了哪些奥秘呢？\n SpringApplication 惊鸿一瞥 SpringApplication 这个类应该算是 SpringBoot 框架 的“创新”产物了，原始的 Spring中并没有这个类，SpringApplication 里面封装了一套 Spring 应用的启动流程，然而这对用户完全透明，因此我们上手 SpringBoot 时感觉简洁、轻量。\n一般来说默认的 SpringApplication 执行流程已经可以满足大部分需求，但是 若用户想干预这个过程，则可以通过 SpringApplication 在流程某些地方开启的 扩展点 来完成对流程的扩展，典型的扩展方案那就是使用 set 方法。\n我们来举一个栗子，把我们天天司空见惯的 SpringBoot 应用的启动类来拆解一下写出来：\n@SpringBootApplication\rpublic class CodeSheepApplication {\rpublic static void main( String[] args ) {\r// SpringApplication.run( CodeSheepApplication.class args ); // 这是传统SpringBoot应用的启动，一行代码搞定，内部默认做了很多事\rSpringApplication app = new SpringApplication( CodeSheepApplication.class );\rapp.setXXX( ... ); // 用户自定的扩展在此 ！！！\rapp.run( args );\r}\r}\r 这样一拆解后我们发现，我们也需要先构造 SpringApplication 类对象，然后调用该对象的 run() 方法。那么接下来就讲讲 SpringApplication 的构造过程 以及其 run() 方法的流程，搞清楚了这个，那么也就搞清楚了SpringBoot应用是如何运行起来的！\n SpringApplication 实例的初始化 我们对照代码来看：\n四个关键的步骤已标注在图中，分别解释如下：\n ① 推断应用的类型：创建的是 REACTIVE应用、SERVLET应用、NONE 三种中的某一种   ② 使用 SpringFactoriesLoader查找并加载 classpath下 META-INF/spring.factories文件中所有可用的 ApplicationContextInitializer   ③ 使用 SpringFactoriesLoader查找并加载 classpath下 META-INF/spring.factories文件中的所有可用的 ApplicationListener   ④ 推断并设置 main方法的定义类    SpringApplication 的run()方法探秘 先看看代码长啥样子：\n各个主要步骤我已经标注在上图之中了，除此之外，我也按照自己的理解画了一个流程图如下所示，可以对照数字标示看一下：\n我们将各步骤总结精炼如下：\n 通过 SpringFactoriesLoader 加载 META-INF/spring.factories 文件，获取并创建 SpringApplicationRunListener 对象 然后由 SpringApplicationRunListener 来发出 starting 消息 创建参数，并配置当前 SpringBoot 应用将要使用的 Environment 完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息 创建 ApplicationContext 初始化 ApplicationContext，并设置 Environment，加载相关配置等 由 SpringApplicationRunListener 来发出 contextPrepared 消息，告知SpringBoot 应用使用的 ApplicationContext 已准备OK 将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 ApplicationContext 已装填OK refresh ApplicationContext，完成IoC容器可用的最后一步 由 SpringApplicationRunListener 来发出 started 消息 完成最终的程序的启动 由 SpringApplicationRunListener 来发出 running 消息，告知程序已运行起来了  至此，全流程结束！\n","id":15,"section":"posts","summary":"转载 · 原文链接：https://www.codesheep.cn/2018/09/04/springboot-startup-process","tags":["SpringBoot"],"title":"SpringBoot应用程序启动过程","uri":"https://bluestaree.github.io/2020/03/springboot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","year":"2020"},{"content":"  转载 · 原文链接：https://www.codesheep.cn/2018/07/30/at-SpringBootApplication-zhujie/\n 概 述 我们在开发基于 SpringBoot 的应用时，用到了一些新的注解和类，正式由于其存在，才让JavaEE的开发如鱼得水。这其中我们用的最多的注解之一，当属 SpringBoot 应用启动类上的 @SpringBootApplication 注解了\n本文就来看看它到底是个啥！\n@SpringBootApplication 背后到底是什么？ @SpringBootApplication注解实际上是SpringBoot提供的一个复合注解，我们来看一看其源码：\n@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@Documented\r@Inherited\r@SpringBootConfiguration\r@EnableAutoConfiguration\r@ComponentScan(excludeFilters = {\r@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\r@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\rpublic @interface SpringBootApplication {\r...\r}\r 看得很清楚，其是一个合成体，但其中最重要的三个注解分别是：\n @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan  我们不妨称其为 “ 三体结构 ” 吧！\n如果我们不怕麻烦，在 SpringBoot 应用的启动类上用这个三个注解代替@SpringBootApplication 注解发现也是没问题的：\n@SpringBootConfiguration\r@EnableAutoConfiguration\r@ComponentScan\rpublic class TestSpringBootApplication {\r...\r}\r 下面分别剖析一下这三个注解的功效！\n  @SpringBootConfiguration 看代码吧，代码里是这样写的：\n@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@Documented\r@Configuration\rpublic @interface SpringBootConfiguration {\r}\r 这说明 @SpringBootConfiguration 也是来源于 @Configuration，二者功能都是将当前类标注为配置类，并将当前类里以 @Bean 注解标记的方法的实例注入到srping容器中，实例名即为方法名。\n至于@Configuration，我想在非SpringBoot时代大家应该不陌生吧，作用是配置Spring容器，也即 JavaConfig 形式的 Spring IoC 容器的配置类所使用。\n到目前来看，好像还没有什么新东西！！！\n  @EnableAutoConfiguration 再继续看代码，代码是这样的：\n@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@Documented\r@Inherited\r@AutoConfigurationPackage\r@Import(AutoConfigurationImportSelector.class)\rpublic @interface EnableAutoConfiguration {\r...\r}\r @EnableAutoConfiguration 注解启用自动配置，其可以帮助 SpringBoot 应用将所有符合条件的 @Configuration 配置都加载到当前 IoC 容器之中，可以简要用图形示意如下：\n@EnableAutoConfiguration 幕后的组件调用关系\n接下来我们对照源码，来解释一下这个流程：\n @EnableAutoConfiguration 借助 AutoConfigurationImportSelector 的帮助，而后者通过实现 selectImports() 方法来导出 Configuration  selectImports()\n AutoConfigurationImportSelector 类的 selectImports() 方法里面通过调用Spring Core 包里 SpringFactoriesLoader 类的 **loadFactoryNames()**方法  SpringFactoriesLoader.loadFactoryNames()\n 最终通过 SpringFactoriesLoader.loadFactoryNames() 读取了 ClassPath 下面的 META-INF/spring.factories 文件来获取所有导出类。  而spring.factories 文件里关于 EnableAutoConfiguration 的配置其实就是一个键值对结构，样子大概长下面这样：\nspring.factories\n说了这么多，如果从稍微宏观一点的角度 概括总结 上述这一过程那就是：\n从 ClassPath下扫描所有的 META-INF/spring.factories 配置文件，并将spring.factories 文件中的 EnableAutoConfiguration 对应的配置项通过反射机制实例化为对应标注了 @Configuration 的形式的IoC容器配置类，然后注入IoC容器。\n@ComponentScan\n@ComponentScan 对应于XML配置形式中的 context:component-scan，用于将一些标注了特定注解的bean定义批量采集注册到Spring的IoC容器之中，这些特定的注解大致包括：\n @Controller @Entity @Component @Service @Repository  等等\n对于该注解，还可以通过 basePackages 属性来更细粒度的控制该注解的自动扫描范围，比如：\n@ComponentScan(basePackages = {\u0026quot;cn.codesheep.controller\u0026quot;,\u0026quot;cn.codesheep.entity\u0026quot;})\r 可见 这个注解也并不是什么新东西！\n","id":16,"section":"posts","summary":"转载 · 原文链接：https://www.codesheep.cn/2018/07/30/at-SpringBootApplication-z","tags":["SpringBoot"],"title":"@SpringBootApplication注解","uri":"https://bluestaree.github.io/2020/03/springbootapplication%E6%B3%A8%E8%A7%A3/","year":"2020"},{"content":" 查看当前所有镜像\ndocker images\n查看所有容器\ndocker ps -a\n根据一个镜像创建一个容器并运行 (windows环境)\ndocker run -d \u0026ndash;name mysql_3308 -e MYSQL_ROOT_HOST=% -e MYSQL_ROOT_PASSWORD=tdt123 -p 3307:3306 -v //f/docker/mysql_3308:/var/lib/mysql mysql:5.5\n \u0026ndash;name mysql_3308 \u0026hellip; mysql:5.5 设置容器名，及选用镜像（如果没有tag即5.5，则会自动下载最新版的mysql） -e MYSQL_ROOT_HOST=% 允许远程登录 -e MYSQL_ROOT_PASSWORD=123456 root登录密码 -p 3308:3306 端口映射至宿主机3308 -d 后台运行容器，并返回容器ID； -v //f/docker/mysql_3308:/var/lib/mysql 绑定镜像位置到宿主机上 \u0026ndash;lower_case_table_names=1 不区分大小写   其他栗子\ndocker run \u0026ndash;name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -v //e/docker/share/mysql_3306:/var/lib/mysql mysql\ndocker create \u0026ndash;name tracker \u0026ndash;net host -v //e/docker/data/tracker:/var/fdfs delron/fastdfs tracker\ndocker create \u0026ndash;name es -p 9200:9200 -p 9300:9300 -e \u0026ldquo;discovery.type=single-node\u0026rdquo; -v //e/docker/es/data/:/usr/share/elasticsearch/data elasticsearch:6.5.4\ndocker create \u0026ndash;name kibana -p 5601:5601 -v //e/docker/es/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml kibana:6.5.4\ndocker create \u0026ndash;name redis -p 6379:6379 -v //e/docker/redis/data:/data redis:5.0.2\n复制当前目录文件至指定容器位置\ndocker cp elasticsearch-analysis-ik-6.5.4.zip es:/usr/share/elasticsearch/plugins/\n启动容器并显示启动日志\ndocker start rabbitmq \u0026amp;\u0026amp; docker logs -f rabbitmq\n进入容器\ndocker exec -it 775c7c9ee1e1 /bin/bash\n 775c7c9ee1e1 为容器ID  查看容器信息\ndokcer inspect 容器名\n查找文件\nfind / -name tracker.conf\n保存镜像文件\ndocker save\ndocker save -o python_3.tar python:3\n加载镜像文件\ndocker load\ndocker load -i python_3.tar\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n","id":17,"section":"posts","summary":"查看当前所有镜像 docker images 查看所有容器 docker ps -a 根据一个镜像创建一个容器并运行 (windows环境) docker run -d \u0026ndash;name mysql_3308 -e MYSQL_ROOT_HOST=% -e MYSQL_ROOT_PASSWORD=tdt123 -p 3307:3306 -v //f/docker/mysql_3308:/var/lib/mysql mysql:5.5 \u0026ndash;name mysql_3308 \u0026hellip; mysql:5.5 设置容器名，及","tags":["docker"],"title":"Docker常用命令","uri":"https://bluestaree.github.io/2020/03/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","year":"2020"},{"content":"  转载 · 原文链接：https://www.codesheep.cn/2018/06/05/SpringBoot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%BA%8E%E5%A4%96%E7%BD%AETomcat%E5%AE%B9%E5%99%A8/\n 0x01. 概述** SpringBoot平时我们用的爽歪歪，爽到它自己连Tomcat都自集成了，我们可以直接编写SBT启动类，然后一键开启内置的Tomcat容器服务，确实是很好上手。但考虑到实际的情形中，我们的Tomcat服务器一般是另外部署好了的，有专门的维护方式。此时我们需要剥离掉SBT应用内置的Tomcat服务器，进而将应用发布并部署到外置的Tomcat容器之中，本文就实践一下这个。\n0x02. 修改打包方式 修改项目的pom.xml配置，我们修改其打包方式为war方式，如：\n\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;\r  0x03. 移除SBT自带的嵌入式Tomcat 修改pom.xml，从maven的pom中移除springboot自带的的嵌入式tomcat插件\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\r\u0026lt;!-- 移除嵌入式tomcat插件 --\u0026gt;\r\u0026lt;exclusions\u0026gt;\r\u0026lt;exclusion\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt;\r\u0026lt;/exclusion\u0026gt;\r\u0026lt;/exclusions\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  0x04. 添加servlet-api依赖 修改pom.xml，在maven的pom中添加servlet-api的依赖\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt;\r\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  0x05. 修改启动类，并重写初始化方法 在SpringBoot中我们平常用main方法启动的方式，都有一个SpringBootApplication的启动类，类似代码如下：\n@SpringBootApplication\rpublic class Application {\rpublic static void main(String[] args) {\rSpringApplication.run(Application.class, args);\r}\r}\r 而我们现在需要类似于web.xml的配置方式来启动spring应用，为此，我们在Application类的同级添加一个SpringBootStartApplication类，其代码如下:\n// 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法\rpublic class SpringBootStartApplication extends SpringBootServletInitializer {\r@Override\rprotected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\r// 注意这里一定要指向原先用main方法执行的Application启动类\rreturn builder.sources(Application.class);\r}\r}\r  0x06. 部署到外部的Tomcat容器并验证  在项目根目录下（即包含pom.xml的目录）记性maven打包操作：  mvn clean package\r 等待打包完成，出现 [INFO] BUILD SUCCESS 即为打包成功\n 然后我们把target目录下生成的war包放到tomcat的webapps目录下，启动tomcat，即可自动解压部署。  最后在浏览器中验证:\nhttp://YOUR_IP:[端口号]/[打包项目名]\r ","id":18,"section":"posts","summary":"转载 · 原文链接：https://www.codesheep.cn/2018/06/05/SpringBoot%E5%BA%94%E7%94%","tags":["SpringBoot"],"title":"SpringBoot应用部署于外置Tomcat容器","uri":"https://bluestaree.github.io/2020/03/springboot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%BA%8E%E5%A4%96%E7%BD%AEtomcat%E5%AE%B9%E5%99%A8/","year":"2020"}],"tags":[{"title":"charset","uri":"https://bluestaree.github.io/tags/charset/"},{"title":"docker","uri":"https://bluestaree.github.io/tags/docker/"},{"title":"equals","uri":"https://bluestaree.github.io/tags/equals/"},{"title":"Gradle","uri":"https://bluestaree.github.io/tags/gradle/"},{"title":"hashCode","uri":"https://bluestaree.github.io/tags/hashcode/"},{"title":"hibernate","uri":"https://bluestaree.github.io/tags/hibernate/"},{"title":"jdk8","uri":"https://bluestaree.github.io/tags/jdk8/"},{"title":"Maven","uri":"https://bluestaree.github.io/tags/maven/"},{"title":"Mybatis","uri":"https://bluestaree.github.io/tags/mybatis/"},{"title":"SpringBoot","uri":"https://bluestaree.github.io/tags/springboot/"},{"title":"SpringSecurity","uri":"https://bluestaree.github.io/tags/springsecurity/"},{"title":"字符集","uri":"https://bluestaree.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"title":"数据库双写","uri":"https://bluestaree.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99/"},{"title":"数据结构","uri":"https://bluestaree.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"算法","uri":"https://bluestaree.github.io/tags/%E7%AE%97%E6%B3%95/"},{"title":"缓存","uri":"https://bluestaree.github.io/tags/%E7%BC%93%E5%AD%98/"}]}